# -*- coding: utf-8 -*-
"""MY SNGAN w/ ping ponging

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1t_uWYneTuYHj_gNQy7lrcW2PIo9Ph9u0
"""

# Commented out IPython magic to ensure Python compatibility.
# %%capture
# """ 
# The Ping Ponging functionality idea has been taken from https://github.com/E-Renshaw/ping-pong-gan author: Edward Renshaw
# SNGAN adapted from https://colab.research.google.com/gist/cwkx/f4b49cd3efc0e624bc22c89c90921931/spectral-norm-gan.ipynb author: Chris Willcocks
# """
# 
# from os.path import exists
# from wheel.pep425tags import get_abbr_impl, get_impl_ver, get_abi_tag
# platform = '{}{}-{}'.format(get_abbr_impl(), get_impl_ver(), get_abi_tag())
# cuda_output = !ldconfig -p|grep cudart.so|sed -e 's/.*\.\([0-9]*\)\.\([0-9]*\)$/cu\1\2/'
# accelerator = cuda_output[0] if exists('/dev/nvidia0') else 'cpu'
# !pip install -q torch torchvision livelossplot

"""**Main imports**"""

import math
import random
import numpy as np
import torch
import torch.nn as nn
import torch.nn.functional as F
import torchvision
import matplotlib.pyplot as plt
from time import sleep
from livelossplot import PlotLosses
import os
from google.colab import drive
drive.mount('/content/drive')

device = torch.device('cuda') if torch.cuda.is_available() else torch.device('cpu')

"""**Import dataset**"""

# helper function to make getting another batch of data easier
def cycle(iterable):
    while True:
        for x in iterable:
            yield x

class_names = ['airplane', 'car', 'bird', 'cat', 'deer', 'dog', 'frog', 'horse', 'ship', 'truck']

train_loader = torch.utils.data.DataLoader(
    torchvision.datasets.CIFAR10('data', train=True, download=True, transform=torchvision.transforms.Compose([
        torchvision.transforms.ToTensor()
    ])),
shuffle=True, batch_size=64, drop_last=True)

"""**Separate horses and birds into their own dataset**"""

horse_images = []
horse_labels = []

bird_images = []
bird_labels = []

# seperating out horses into a new dataset and dataloader
for i in range(0, len(train_loader.dataset)):

  class_label = train_loader.dataset[i][1]

  if class_label == 7:
    image, label = train_loader.dataset[i]
    horse_images.append(image)
    horse_labels.append(label)
  
  elif class_label == 2:
    image, label = train_loader.dataset[i]
    bird_images.append(image)
    bird_labels.append(label)

# create horse trainloader
horse_images = torch.stack(horse_images)
horse_labels = torch.LongTensor(horse_labels)

horse_dataset = torch.utils.data.TensorDataset(horse_images, horse_labels)
horse_train_loader = torch.utils.data.DataLoader(horse_dataset, shuffle=True, batch_size=64, drop_last=True)

horse_train_iterator = iter(cycle(horse_train_loader))
print(f'> Size of training dataset {len(horse_train_loader.dataset)}')

# create bird trainloader
bird_images = torch.stack(bird_images)
bird_labels = torch.LongTensor(bird_labels)

bird_dataset = torch.utils.data.TensorDataset(bird_images, bird_labels)
bird_train_loader = torch.utils.data.DataLoader(bird_dataset, shuffle=True, batch_size=64, drop_last=True)

bird_train_iterator = iter(cycle(bird_train_loader))
print(f'> Size of training dataset {len(bird_train_loader.dataset)}')

"""**Define two models: (1) Generator, and (2) Discriminator**"""

# define the model
class Generator(nn.Module):
    def __init__(self, f=64):
        super(Generator, self).__init__()
        self.generate = nn.Sequential(
            nn.ConvTranspose2d(100, f*8, 4, 2, 1, bias=False),
            nn.BatchNorm2d(64*8),
            nn.ReLU(True),
            nn.ConvTranspose2d(f*8, f*4, 4, 2, 1, bias=False),
            nn.BatchNorm2d(f*4),
            nn.ReLU(True),
            nn.ConvTranspose2d(f*4, f*2, 4, 2, 1, bias=False),
            nn.BatchNorm2d(f*2),
            nn.ReLU(True),
            nn.ConvTranspose2d(f*2, f, 4, 2, 1, bias=False),
            nn.BatchNorm2d(f),
            nn.ReLU(True),
            nn.ConvTranspose2d(f, 3, 4, 2, 1, bias=False),
            nn.Sigmoid()
        )

# try mean pooling
class Discriminator(nn.Module):
    def __init__(self, f=64):
        super(Discriminator, self).__init__()
        self.discriminate = nn.Sequential(
            torch.nn.utils.spectral_norm(nn.Conv2d(3, f, 3, 1, 1)),
            nn.LeakyReLU(0.1, inplace=True),
            nn.MaxPool2d(kernel_size=(2,2)),
            torch.nn.utils.spectral_norm(nn.Conv2d(f, f*2, 3, 1, 1)),
            nn.LeakyReLU(0.1, inplace=True),
            nn.MaxPool2d(kernel_size=(2,2)),
            torch.nn.utils.spectral_norm(nn.Conv2d(f*2, f*4, 3, 1, 1)),
            nn.LeakyReLU(0.1, inplace=True),
            nn.MaxPool2d(kernel_size=(2,2)),
            torch.nn.utils.spectral_norm(nn.Conv2d(f*4, f*8, 3, 1, 1)),
            nn.LeakyReLU(0.1, inplace=True),
            nn.MaxPool2d(kernel_size=(2,2)),
            torch.nn.utils.spectral_norm(nn.Conv2d(f*8, 1, 3, 1, 1)),
            nn.MaxPool2d(kernel_size=(2,2)),
            nn.Sigmoid()
        )

# create separate G and Ds for horses and birds, and two for the pegasus generator
G = Generator().to(device)
D = Discriminator().to(device)

# load previously trained generator and discriminator each for horse and bird
epoch_number = 309

path_G = F"/content/drive/My Drive/University Work/Year 3/Software, Systems, & Applications III/Deep Learning/G_{epoch_number}.pth"
path_D = F"/content/drive/My Drive/University Work/Year 3/Software, Systems, & Applications III/Deep Learning/D_{epoch_number}.pth"
G.load_state_dict(torch.load(path_G))
D.load_state_dict(torch.load(path_D))

# initialise the optimiser
optimiser_G = torch.optim.Adam(G.parameters(), lr=0.001)
optimiser_D = torch.optim.Adam(D.parameters(), lr=0.001)

bce_loss = nn.BCELoss()
epoch = 0
liveplot = PlotLosses()

"""**Main training loop for both horses and birds**"""

liveplot = PlotLosses()

train_iterator = horse_train_iterator

# training loop
while (epoch < 310):
    
    # ping pong functionality
    if 0 <= epoch < 80:
        train_iterator = horse_train_iterator
    elif 80 <= epoch < 130:
        train_iterator = bird_train_iterator
    elif 130 <= epoch <= 190:
        train_iterator = horse_train_iterator
    elif 190 <= epoch < 220:
        train_iterator = bird_train_iterator
    elif 220 <= epoch < 260:
        train_iterator = horse_train_iterator
    elif 260 <= epoch < 275:
        train_iterator = bird_train_iterator
    elif 275 <= epoch < 295:
        train_iterator = horse_train_iterator
    elif 290 <= epoch < 300:
        train_iterator = bird_train_iterator
    elif epoch >= 300:
        train_iterator = horse_train_iterator

    # arrays for metrics
    logs = {}
    gen_loss_arr = np.zeros(0)
    dis_loss_arr = np.zeros(0)

    # iterate over some of the train dateset
    for i in range(100):

        # train discriminator 
        for j in range(5):
            x,t = next(train_iterator)
            x,t = x.to(device), t.to(device)
            optimiser_D.zero_grad()
            g = G.generate(torch.randn(x.size(0), 100, 1, 1).to(device))
            l_r = bce_loss(D.discriminate(x).mean(), torch.ones(1)[0].to(device)) # real -> 1
            l_f = bce_loss(D.discriminate(g.detach()).mean(), torch.zeros(1)[0].to(device)) #  fake -> 0
            loss_d = (l_r + l_f)/2.0
            loss_d.backward()
            optimiser_D.step()
          
        # train generator
        x,t = next(train_iterator)
        x,t = x.to(device), t.to(device)
        optimiser_G.zero_grad()
        g = G.generate(torch.randn(x.size(0), 100, 1, 1).to(device))
        loss_g = bce_loss(D.discriminate(g).mean(), torch.ones(1)[0].to(device)) # fake -> 1
        loss_g.backward()
        optimiser_G.step()

        gen_loss_arr = np.append(gen_loss_arr, loss_g.item())
        dis_loss_arr = np.append(dis_loss_arr, loss_d.item())

    # saving the model once it finishes running
    if epoch == 309:
      torch.save(G.state_dict(), os.path.join('/', 'content', 'drive', 'My Drive', 'University Work', 'Year 3', 'Software, Systems, & Applications III', 'Deep Learning', f'G_{epoch}.pth'))
      torch.save(D.state_dict(), os.path.join('/', 'content', 'drive', 'My Drive', 'University Work', 'Year 3', 'Software, Systems, & Applications III', 'Deep Learning', f'D_{epoch}.pth'))
    
    # plot some examples
    plt.grid(False)
    plt.imshow(torchvision.utils.make_grid(g).cpu().data.permute(0,2,1).contiguous().permute(2,1,0), cmap=plt.cm.binary)

    liveplot.update({
        'generator loss': gen_loss_arr.mean(),
        'discriminator loss': dis_loss_arr.mean()
    })
    liveplot.draw()
    sleep(1.)

    epoch = epoch + 1

"""**Sample a batch from the generative model to show the output diversity**"""

G.eval()

horse_seed = random.randint(0, 1000000000)
print(horse_seed)

torch.manual_seed(460150825)  # change to horse_seed for random batches
horses = G.generate(torch.randn(100, 100, 1, 1).to(device))

# batch of 64
plt.figure(figsize=(8, 8))
for i in range(64):
    plt.subplot(8,8,i+1)
    plt.xticks([])
    plt.yticks([])
    plt.grid(False)
    plt.imshow(horses[i].permute(0,2,1).cpu().detach().contiguous().permute(2,1,0), cmap=plt.cm.binary)

"""**Display the Pegasus**"""

torch.manual_seed(460150825)  # change to horse seed for the batch above

pegasus_tensor = torch.randn(100, 100, 1, 1).to(device)[36]  # change from 0-63 to display one of the pegasuses above
pegasus_tensor = pegasus_tensor.unsqueeze(0)
pegasus = G.generate(pegasus_tensor)
plt.imshow(pegasus[0].cpu().data.permute(0, 2, 1).contiguous().permute(2, 1, 0), cmap=plt.cm.binary)

"""Sample a batch from the generative model to show the output diversity"""